pub struct Extension {
    pub character: char,
    pub filename: &'static str,
}

fn max(a: usize,b: usize) -> usize {
    if b > a {
        return b;
    }
    return a;
}

pub fn translate_rust(code: String, extensions: Vec<Extension>) -> String
{
    //GUIDE:
    //>: data_ptr += 1;
    //<: data_ptr -= 1;
    //+: memory[data_ptr as usize] += 1;
    //-: memory[data_ptr as usize] -= 1;
    //.: print!("{}", memory[data_ptr as usize] as char);
    //,: Complicated... Check code lol
    //[: while (memory[data_ptr as usize] > 0) {
    //]: }

    let mut indent = 1;
    let header = "//Rust-brainfuck code. Generated by Lucky4Luuk's Brainfuck to Rust transpiler.
use std::io::Read;

fn main() {
    let mut memory: [u8; 65536] = [0; 65536];
    let mut data_ptr: u8 = 0;\n\n//Brainfuck code\n";

    //gaming time
    let mut final_code = String::new();
    let code_array: Vec<char> = code.chars().collect();

    let mut token_array: Vec<(char, usize)> = Vec::new();

    for c in code_array {
        if c == '>' || c == '<' || c == '+' || c == '-' {
            //We need to take count
            if let Some(last) = token_array.last_mut() {
                if last.0 == c {
                    last.1 += 1;
                } else {
                    token_array.push( (c, 1) );
                }
            } else {
                token_array.push( (c, 1) );
            }
        } else if c == ',' || c == '.' || c == '[' || c == ']' {
            //No need to count, we can't optimise these at the moment
            token_array.push( (c, 1) );
        }
    }

    //TODO: Optimise by treating it as tokens, not characters, and including a count for how many tokens in a row, so we can do `+= 5` for instance, instead of `+= 1` 5 times
    for token in token_array {
        let c = token.0;
        // print!("{}", c);
        if c == '>' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("data_ptr += "); final_code.push_str(&token.1.to_string()); final_code.push_str(";\n"); }
        if c == '<' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("data_ptr -= "); final_code.push_str(&token.1.to_string()); final_code.push_str(";\n"); }
        if c == '+' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("memory[data_ptr as usize] += "); final_code.push_str(&token.1.to_string()); final_code.push_str(";\n"); }
        if c == '-' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("memory[data_ptr as usize] -= "); final_code.push_str(&token.1.to_string()); final_code.push_str(";\n"); }

        // if c == ',' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("//Not implemented yet!\n"); }
        if c == ',' {
            final_code.push_str("let input: Option<u8> = std::io::stdin().bytes().next().and_then(|result| result.ok());\n");
            final_code.push_str("memory[data_ptr as usize] = match input {
                Some(x) => x,
                None => 0,
            };\n");
        }

        if c == '.' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("print!(\"{}\", memory[data_ptr as usize] as char);\n"); }
        if c == '[' {
            final_code.push_str(&"    ".repeat(indent)); final_code.push_str("while (memory[data_ptr as usize] > 0) {\n");
            indent += 1;
        }
        if c == ']' {
            final_code.push_str(&"    ".repeat(max(indent - 1, 0))); final_code.push_str("}\n");
            if indent > 0 {
                indent -= 1;
            } else {
                //Error
                println!("Something went funky");
            }
        }
    }

    let footer = "}";

    let result = header.to_string() + &final_code + footer;

    return result;
}
