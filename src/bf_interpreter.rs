fn max(a: usize,b: usize) -> usize {
    if b > a {
        return b;
    }
    return a;
}

pub fn translate_rust(code: String) -> String
{
    //GUIDE:
    //>: data_ptr += 1;
    //<: data_ptr -= 1;
    //+: memory[data_ptr as usize] += 1;
    //-: memory[data_ptr as usize] -= 1;
    //.: print!("{}", memory[data_ptr as usize] as char);
    //,: Complicated... Check code lol
    //[: while (memory[data_ptr as usize] > 0) {
    //]: }

    //TODO: Write some basic code before translating the bf code. Let it set up the memory and shit like that.
    //Also, filter out any non-brainfuck characters. We don't care about comments in the final compiled version.
    //Then, we simply translate the code according to the code above, and then we call the rust compiler on that.

    let mut indent = 1;
    let header = "//Rust bf code. Generated by Lucky4Luuk's BF to Rust transpiler.
use std::io::Read;

fn main() {
    let mut memory: [u8; 65536] = [0; 65536];
    let mut data_ptr: u8 = 0;\n\n";

    //gaming time
    let mut final_code = String::new();
    let code_array: Vec<char> = code.chars().collect();
    for c in code_array {
        if c == '>' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("data_ptr += 1;\n"); }
        if c == '<' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("data_ptr -= 1;\n"); }
        if c == '+' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("memory[data_ptr as usize] += 1;\n"); }
        if c == '-' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("memory[data_ptr as usize] -= 1;\n"); }

        // if c == ',' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("//Not implemented yet!\n"); }
        if c == ',' {
            final_code.push_str("let input: Option<u8> = std::io::stdin().bytes().next().and_then(|result| result.ok());\n");
            final_code.push_str("memory[data_ptr as usize] = match input {
                Some(x) => x,
                None => 0,
            };\n");
        }

        if c == '.' { final_code.push_str(&"    ".repeat(indent)); final_code.push_str("print!(\"{}\", memory[data_ptr as usize] as char);\n"); }
        if c == '[' {
            final_code.push_str(&"    ".repeat(indent)); final_code.push_str("while (memory[data_ptr as usize] > 0) {\n");
            indent += 1;
        }
        if c == ']' {
            final_code.push_str(&"    ".repeat(max(indent - 1, 0))); final_code.push_str("}\n");
            if indent > 0 {
                indent -= 1;
            } else {
                //Error
                println!("Something went funky");
            }
        }
    }

    let footer = "}";

    let result = header.to_string() + &final_code + footer;

    return result;
}

pub fn interpret(code: String)
{
    let mut array: [u8; 65536] = [0; 65536];
    interpret_mapped(code, array);
}

pub fn interpret_mapped(code: String, mut array: [u8; 65536]) {
    let code_array: Vec<char> = code.chars().collect();

    let mut output = String::new();
    let mut data_ptr: u8 = 0;
    let mut code_ptr: usize = 0;
    let mut finished: bool = false;

    'interpret: while !finished {
        let c = code_array[code_ptr];

        if c == '>' { data_ptr+=1; }
        if c == '<' { data_ptr-=1; }
        if c == '+' { array[data_ptr as usize]+=1; }
        if c == '-' { array[data_ptr as usize]-=1; }
        if c == '.' { output.push(array[data_ptr as usize] as char); }
        if c == ',' { continue; } //TODO: Implement this
        if c == '[' {
            if array[data_ptr as usize] == 0 {
                //Search for the matching ]
                let mut found_ptr: usize = code_ptr;
                let mut depth: u8 = 0;
                'search: for i in code_ptr+1..code_array.len() {
                    let search_c: char = code_array[i];
                    if search_c == '[' {
                        depth+=1;
                    } else if search_c == ']' {
                        if depth == 0 {
                            found_ptr = i;
                            break 'search; //Found the right bracket
                        } else {
                            depth-=1;
                        }
                    }
                }

                if code_ptr == found_ptr {
                    //HELP IT BROKE
                    println!("Syntax error in loop at location {}", code_ptr);
                    finished = true;
                }

                code_ptr = found_ptr + 1;
            }
        }
        if c == ']' {
            if array[data_ptr as usize] != 0 {
                //Search for the matching ]
                let mut found_ptr: usize = code_ptr;
                let mut depth: u8 = 0;
                'search: for i in (0..code_ptr).rev() {
                    let search_c: char = code_array[i];
                    if search_c == ']' {
                        depth+=1;
                    } else if search_c == '[' {
                        if depth == 0 {
                            found_ptr = i;
                            break 'search; //Found the right bracket
                        } else {
                            depth-=1;
                        }
                    }
                }

                if code_ptr == found_ptr {
                    //HELP IT BROKE
                    println!("Syntax error in loop at location {}", code_ptr);
                    finished = true;
                }

                code_ptr = found_ptr;
            }
        }

        code_ptr+=1;
        if code_ptr >= code_array.len() {
            finished = true;
            println!("{}",output);
        }
    }
}
